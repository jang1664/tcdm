`timescale 1ns / 1ps

// Auto-generated wrapper for tcdm_xbar
// Generated by generate_fpga_wrapper.py

module tcdm_xbar_wrap #(
    parameter int NUM_MASTER = 2,
    parameter int NUM_SLAVE = 2,
    parameter int DATA_WIDTH = 32,
    parameter int ADDR_WIDTH = 32,
    parameter int BE_WIDTH = DATA_WIDTH / 8,
    // Interface port parameters
    parameter int master_ports_ADDR_WIDTH = 32,
    parameter int master_ports_DATA_WIDTH = 32,
    parameter int master_ports_RVALID_ASSERT = 1'b1,
    parameter int master_ports_REQ_HOLD_ASSERT = 1'b1,
    parameter int master_ports_RDATA_HOLD_ASSERT = 1'b1,
    parameter int slave_ports_ADDR_WIDTH = 32,
    parameter int slave_ports_DATA_WIDTH = 32,
    parameter int slave_ports_RVALID_ASSERT = 1'b1,
    parameter int slave_ports_REQ_HOLD_ASSERT = 1'b1,
    parameter int slave_ports_RDATA_HOLD_ASSERT = 1'b1,
    // Wrapper-specific parameters
    parameter int NUM_INSTANCES     = 1,
    parameter int BUFFER_DEPTH      = 32,
    parameter int WRAPPER_INPUT_DW  = 8,
    parameter int WRAPPER_OUTPUT_DW = 1
) (
    input logic clk_i,
    input logic resetn_i,
    input logic [NUM_MASTER] master_ports_req,
    input logic [NUM_MASTER] master_ports_gnt,
    input logic [NUM_MASTER] master_ports_wen,
    input logic [NUM_MASTER] master_ports_r_valid,
    input logic [NUM_MASTER] master_ports_r_ready,
    output logic [NUM_SLAVE] slave_ports_req,
    output logic [NUM_SLAVE] slave_ports_gnt,
    output logic [NUM_SLAVE] slave_ports_wen,
    output logic [NUM_SLAVE] slave_ports_r_valid,
    output logic [NUM_SLAVE] slave_ports_r_ready,
    // Write interface for master_ports_addr buffer (per instance),
    input  logic [NUM_INSTANCES-1:0] master_ports_addr_buf_ena,
    input  logic [NUM_INSTANCES-1:0] master_ports_addr_buf_wea,
    input  logic [NUM_INSTANCES-1:0][$clog2(((master_ports_ADDR_WIDTH-1+1)*(NUM_MASTER+1)+7)/8)-1:0] master_ports_addr_buf_wr_sel,
    input  logic [NUM_INSTANCES-1:0][WRAPPER_INPUT_DW-1:0] master_ports_addr_buf_wr_data,
    // Write interface for master_ports_be buffer (per instance),
    input  logic [NUM_INSTANCES-1:0] master_ports_be_buf_ena,
    input  logic [NUM_INSTANCES-1:0] master_ports_be_buf_wea,
    input  logic [NUM_INSTANCES-1:0][$clog2((((master_ports_DATA_WIDTH/8)-1+1)*(NUM_MASTER+1)+7)/8)-1:0] master_ports_be_buf_wr_sel,
    input  logic [NUM_INSTANCES-1:0][WRAPPER_INPUT_DW-1:0] master_ports_be_buf_wr_data,
    // Write interface for master_ports_data buffer (per instance),
    input  logic [NUM_INSTANCES-1:0] master_ports_data_buf_ena,
    input  logic [NUM_INSTANCES-1:0] master_ports_data_buf_wea,
    input  logic [NUM_INSTANCES-1:0][$clog2(((master_ports_DATA_WIDTH-1+1)*(NUM_MASTER+1)+7)/8)-1:0] master_ports_data_buf_wr_sel,
    input  logic [NUM_INSTANCES-1:0][WRAPPER_INPUT_DW-1:0] master_ports_data_buf_wr_data,
    // Write interface for master_ports_r_data buffer (per instance),
    input  logic [NUM_INSTANCES-1:0] master_ports_r_data_buf_ena,
    input  logic [NUM_INSTANCES-1:0] master_ports_r_data_buf_wea,
    input  logic [NUM_INSTANCES-1:0][$clog2(((master_ports_DATA_WIDTH-1+1)*(NUM_MASTER+1)+7)/8)-1:0] master_ports_r_data_buf_wr_sel,
    input  logic [NUM_INSTANCES-1:0][WRAPPER_INPUT_DW-1:0] master_ports_r_data_buf_wr_data,
    // Read interface for slave_ports_addr buffer (per instance),
    input  logic [NUM_INSTANCES-1:0] slave_ports_addr_buf_ena,
    input  logic [NUM_INSTANCES-1:0] slave_ports_addr_buf_wea,
    input  logic [NUM_INSTANCES-1:0][$clog2((slave_ports_ADDR_WIDTH-1+1)*(NUM_SLAVE+1))-1:0] slave_ports_addr_buf_rd_sel,
    output logic [NUM_INSTANCES-1:0][WRAPPER_OUTPUT_DW-1:0] slave_ports_addr_buf_rd_data,
    // Read interface for slave_ports_be buffer (per instance),
    input  logic [NUM_INSTANCES-1:0] slave_ports_be_buf_ena,
    input  logic [NUM_INSTANCES-1:0] slave_ports_be_buf_wea,
    input  logic [NUM_INSTANCES-1:0][$clog2(((slave_ports_DATA_WIDTH/8)-1+1)*(NUM_SLAVE+1))-1:0] slave_ports_be_buf_rd_sel,
    output logic [NUM_INSTANCES-1:0][WRAPPER_OUTPUT_DW-1:0] slave_ports_be_buf_rd_data,
    // Read interface for slave_ports_data buffer (per instance),
    input  logic [NUM_INSTANCES-1:0] slave_ports_data_buf_ena,
    input  logic [NUM_INSTANCES-1:0] slave_ports_data_buf_wea,
    input  logic [NUM_INSTANCES-1:0][$clog2((slave_ports_DATA_WIDTH-1+1)*(NUM_SLAVE+1))-1:0] slave_ports_data_buf_rd_sel,
    output logic [NUM_INSTANCES-1:0][WRAPPER_OUTPUT_DW-1:0] slave_ports_data_buf_rd_data,
    // Read interface for slave_ports_r_data buffer (per instance),
    input  logic [NUM_INSTANCES-1:0] slave_ports_r_data_buf_ena,
    input  logic [NUM_INSTANCES-1:0] slave_ports_r_data_buf_wea,
    input  logic [NUM_INSTANCES-1:0][$clog2((slave_ports_DATA_WIDTH-1+1)*(NUM_SLAVE+1))-1:0] slave_ports_r_data_buf_rd_sel,
    output logic [NUM_INSTANCES-1:0][WRAPPER_OUTPUT_DW-1:0] slave_ports_r_data_buf_rd_data
);

  // =========================================================================
  // Internal signals
  // =========================================================================

  // Registered control signals (per instance)
  logic [NUM_MASTER] master_ports_req_q;
  logic [NUM_MASTER] master_ports_gnt_q;
  logic [NUM_MASTER] master_ports_wen_q;
  logic [NUM_MASTER] master_ports_r_valid_q;
  logic [NUM_MASTER] master_ports_r_ready_q;
  logic [NUM_SLAVE] slave_ports_req_q;
  logic [NUM_SLAVE] slave_ports_gnt_q;
  logic [NUM_SLAVE] slave_ports_wen_q;
  logic [NUM_SLAVE] slave_ports_r_valid_q;
  logic [NUM_SLAVE] slave_ports_r_ready_q;

  // Module connection signals (per instance)
  logic [NUM_MASTER] tcdm_xbar_master_ports_req;
  logic [NUM_MASTER] tcdm_xbar_master_ports_gnt;
  logic [    master_ports_ADDR_WIDTH-1:0][NUM_MASTER] tcdm_xbar_master_ports_addr;
  logic [NUM_MASTER] tcdm_xbar_master_ports_wen;
  logic [(master_ports_DATA_WIDTH/8)-1:0][NUM_MASTER] tcdm_xbar_master_ports_be;
  logic [    master_ports_DATA_WIDTH-1:0][NUM_MASTER] tcdm_xbar_master_ports_data;
  logic [    master_ports_DATA_WIDTH-1:0][NUM_MASTER] tcdm_xbar_master_ports_r_data;
  logic [NUM_MASTER] tcdm_xbar_master_ports_r_valid;
  logic [NUM_MASTER] tcdm_xbar_master_ports_r_ready;
  logic [NUM_SLAVE] tcdm_xbar_slave_ports_req;
  logic [NUM_SLAVE] tcdm_xbar_slave_ports_gnt;
  logic [    slave_ports_ADDR_WIDTH-1:0][NUM_SLAVE] tcdm_xbar_slave_ports_addr;
  logic [NUM_SLAVE] tcdm_xbar_slave_ports_wen;
  logic [(slave_ports_DATA_WIDTH/8)-1:0][NUM_SLAVE] tcdm_xbar_slave_ports_be;
  logic [    slave_ports_DATA_WIDTH-1:0][NUM_SLAVE] tcdm_xbar_slave_ports_data;
  logic [    slave_ports_DATA_WIDTH-1:0][NUM_SLAVE] tcdm_xbar_slave_ports_r_data;
  logic [NUM_SLAVE] tcdm_xbar_slave_ports_r_valid;
  logic [NUM_SLAVE] tcdm_xbar_slave_ports_r_ready;

  // Interface objects for module connection
  mem_intf #(
    .ADDR_WIDTH(master_ports_ADDR_WIDTH),
    .DATA_WIDTH(master_ports_DATA_WIDTH),
    .RVALID_ASSERT(master_ports_RVALID_ASSERT),
    .REQ_HOLD_ASSERT(master_ports_REQ_HOLD_ASSERT),
    .RDATA_HOLD_ASSERT(master_ports_RDATA_HOLD_ASSERT)
  ) master_ports_intf[NUM_MASTER] (.clk(clk_i));
  mem_intf #(
    .ADDR_WIDTH(slave_ports_ADDR_WIDTH),
    .DATA_WIDTH(slave_ports_DATA_WIDTH),
    .RVALID_ASSERT(slave_ports_RVALID_ASSERT),
    .REQ_HOLD_ASSERT(slave_ports_REQ_HOLD_ASSERT),
    .RDATA_HOLD_ASSERT(slave_ports_RDATA_HOLD_ASSERT)
  ) slave_ports_intf[NUM_SLAVE] (.clk(clk_i));


  // =========================================================================
  // Control signal registers (DFF) - per instance
  // =========================================================================

  always_ff @(posedge clk_i or negedge resetn_i) begin
    if (!resetn_i) begin
      master_ports_req_q <= '0;
      master_ports_gnt_q <= '0;
      master_ports_wen_q <= '0;
      master_ports_r_valid_q <= '0;
      master_ports_r_ready_q <= '0;
      slave_ports_req_q <= '0;
      slave_ports_gnt_q <= '0;
      slave_ports_wen_q <= '0;
      slave_ports_r_valid_q <= '0;
      slave_ports_r_ready_q <= '0;
    end else begin
      master_ports_req_q <= master_ports_req;
      master_ports_gnt_q <= master_ports_gnt;
      master_ports_wen_q <= master_ports_wen;
      master_ports_r_valid_q <= master_ports_r_valid;
      master_ports_r_ready_q <= master_ports_r_ready;
    end
  end

  // =========================================================================
  // Interface connections (wrapper ports <-> interface objects)
  // =========================================================================

  // Connect master_ports (mem_intf.slave)
  generate
    for (genvar i = 0; i < NUM_MASTER; i++) begin : gen_master_ports_conn
      assign master_ports_intf[i].req = master_ports_req_q[i];
      assign master_ports_gnt[i] = master_ports_intf[i].gnt;
      assign master_ports_intf[i].addr = master_ports_addr[i];
      assign master_ports_intf[i].wen = master_ports_wen_q[i];
      assign master_ports_intf[i].be = master_ports_be[i];
      assign master_ports_intf[i].data = master_ports_data[i];
      assign master_ports_r_data[i] = master_ports_intf[i].r_data;
      assign master_ports_r_valid[i] = master_ports_intf[i].r_valid;
      assign master_ports_intf[i].r_ready = master_ports_r_ready_q[i];
    end
  endgenerate

  // Connect slave_ports (mem_intf.master)
  generate
    for (genvar i = 0; i < NUM_SLAVE; i++) begin : gen_slave_ports_conn
      assign slave_ports_req[i] = slave_ports_intf[i].req;
      assign slave_ports_intf[i].gnt = slave_ports_gnt[i];
      assign slave_ports_addr[i] = slave_ports_intf[i].addr;
      assign slave_ports_wen[i] = slave_ports_intf[i].wen;
      assign slave_ports_be[i] = slave_ports_intf[i].be;
      assign slave_ports_data[i] = slave_ports_intf[i].data;
      assign slave_ports_intf[i].r_data = slave_ports_r_data[i];
      assign slave_ports_intf[i].r_valid = slave_ports_r_valid[i];
      assign slave_ports_r_ready[i] = slave_ports_intf[i].r_ready;
    end
  endgenerate


  // =========================================================================
  // Input buffers (BRAM with 8-bit demux) - per instance
  // =========================================================================

  // Buffer for master_ports_addr - BRAM data width = (master_ports_ADDR_WIDTH-1+1)*(NUM_MASTER+1)
  localparam int MASTER_PORTS_ADDR_BUF_DW = (master_ports_ADDR_WIDTH-1+1)*(NUM_MASTER+1);
  localparam int MASTER_PORTS_ADDR_BUF_NB_COL = (MASTER_PORTS_ADDR_BUF_DW + 7) / 8;  // Number of bytes
  localparam int MASTER_PORTS_ADDR_BUF_AW = $clog2(BUFFER_DEPTH);

  generate
    for (genvar inst = 0; inst < NUM_INSTANCES; inst++) begin : gen_master_ports_addr_ibuf

      logic [MASTER_PORTS_ADDR_BUF_NB_COL*8-1:0] master_ports_addr_buf_demux_out;
      logic [MASTER_PORTS_ADDR_BUF_NB_COL-1:0] master_ports_addr_buf_demux_wea;
      logic [MASTER_PORTS_ADDR_BUF_NB_COL*8-1:0] master_ports_addr_buf_bram_out;

      // 8-bit Demux: 8-bit input -> (master_ports_ADDR_WIDTH-1+1)*(NUM_MASTER+1)-bit BRAM data
      always_comb begin
        master_ports_addr_buf_demux_out = '0;
        master_ports_addr_buf_demux_wea = '0;
        if (master_ports_addr_buf_wr_sel[inst] < MASTER_PORTS_ADDR_BUF_NB_COL) begin
          // Check if this is the last byte
          if (master_ports_addr_buf_wr_sel[inst] == MASTER_PORTS_ADDR_BUF_NB_COL - 1 && MASTER_PORTS_ADDR_BUF_DW % 8 != 0) begin
            // Last byte: only connect the necessary LSBs
            master_ports_addr_buf_demux_out[master_ports_addr_buf_wr_sel[inst]*8 +: (MASTER_PORTS_ADDR_BUF_DW % 8)] = master_ports_addr_buf_wr_data[inst][(MASTER_PORTS_ADDR_BUF_DW % 8)-1:0];
          end else begin
            // Full byte
            master_ports_addr_buf_demux_out[master_ports_addr_buf_wr_sel[inst]*8 +: 8] = master_ports_addr_buf_wr_data[inst];
          end
          master_ports_addr_buf_demux_wea[master_ports_addr_buf_wr_sel[inst]] = master_ports_addr_buf_wea[inst];
        end
      end

      // BRAM with byte write enable for master_ports_addr
      xilinx_single_port_byte_write_ram_read_first #(
        .NB_COL(MASTER_PORTS_ADDR_BUF_NB_COL),
        .COL_WIDTH(8),
        .RAM_DEPTH(BUFFER_DEPTH),
        .RAM_PERFORMANCE("HIGH_PERFORMANCE"),
        .INIT_FILE("")
      ) master_ports_addr_bram (
        .clka   (clk_i),
        .ena    (master_ports_addr_buf_ena[inst]),
        .wea    (master_ports_addr_buf_demux_wea),
        .addra  ({(MASTER_PORTS_ADDR_BUF_AW){1'b0}}),  // Fixed address 0
        .dina   (master_ports_addr_buf_demux_out),
        .rsta   (!resetn_i),
        .regcea (1'b1),
        .douta  (master_ports_addr_buf_bram_out)
      );

      // Connect BRAM output to module input (truncate if needed)
      assign tcdm_xbar_master_ports_addr = master_ports_addr_buf_bram_out[MASTER_PORTS_ADDR_BUF_DW-1:0];

    end
  endgenerate

  // Buffer for master_ports_be - BRAM data width = ((master_ports_DATA_WIDTH/8)-1+1)*(NUM_MASTER+1)
  localparam int MASTER_PORTS_BE_BUF_DW = ((master_ports_DATA_WIDTH/8)-1+1)*(NUM_MASTER+1);
  localparam int MASTER_PORTS_BE_BUF_NB_COL = (MASTER_PORTS_BE_BUF_DW + 7) / 8;  // Number of bytes
  localparam int MASTER_PORTS_BE_BUF_AW = $clog2(BUFFER_DEPTH);

  generate
    for (genvar inst = 0; inst < NUM_INSTANCES; inst++) begin : gen_master_ports_be_ibuf

      logic [MASTER_PORTS_BE_BUF_NB_COL*8-1:0] master_ports_be_buf_demux_out;
      logic [MASTER_PORTS_BE_BUF_NB_COL-1:0] master_ports_be_buf_demux_wea;
      logic [MASTER_PORTS_BE_BUF_NB_COL*8-1:0] master_ports_be_buf_bram_out;

      // 8-bit Demux: 8-bit input -> ((master_ports_DATA_WIDTH/8)-1+1)*(NUM_MASTER+1)-bit BRAM data
      always_comb begin
        master_ports_be_buf_demux_out = '0;
        master_ports_be_buf_demux_wea = '0;
        if (master_ports_be_buf_wr_sel[inst] < MASTER_PORTS_BE_BUF_NB_COL) begin
          // Check if this is the last byte
          if (master_ports_be_buf_wr_sel[inst] == MASTER_PORTS_BE_BUF_NB_COL - 1 && MASTER_PORTS_BE_BUF_DW % 8 != 0) begin
            // Last byte: only connect the necessary LSBs
            master_ports_be_buf_demux_out[master_ports_be_buf_wr_sel[inst]*8 +: (MASTER_PORTS_BE_BUF_DW % 8)] = master_ports_be_buf_wr_data[inst][(MASTER_PORTS_BE_BUF_DW % 8)-1:0];
          end else begin
            // Full byte
            master_ports_be_buf_demux_out[master_ports_be_buf_wr_sel[inst]*8 +: 8] = master_ports_be_buf_wr_data[inst];
          end
          master_ports_be_buf_demux_wea[master_ports_be_buf_wr_sel[inst]] = master_ports_be_buf_wea[inst];
        end
      end

      // BRAM with byte write enable for master_ports_be
      xilinx_single_port_byte_write_ram_read_first #(
        .NB_COL(MASTER_PORTS_BE_BUF_NB_COL),
        .COL_WIDTH(8),
        .RAM_DEPTH(BUFFER_DEPTH),
        .RAM_PERFORMANCE("HIGH_PERFORMANCE"),
        .INIT_FILE("")
      ) master_ports_be_bram (
        .clka   (clk_i),
        .ena    (master_ports_be_buf_ena[inst]),
        .wea    (master_ports_be_buf_demux_wea),
        .addra  ({(MASTER_PORTS_BE_BUF_AW){1'b0}}),  // Fixed address 0
        .dina   (master_ports_be_buf_demux_out),
        .rsta   (!resetn_i),
        .regcea (1'b1),
        .douta  (master_ports_be_buf_bram_out)
      );

      // Connect BRAM output to module input (truncate if needed)
      assign tcdm_xbar_master_ports_be = master_ports_be_buf_bram_out[MASTER_PORTS_BE_BUF_DW-1:0];

    end
  endgenerate

  // Buffer for master_ports_data - BRAM data width = (master_ports_DATA_WIDTH-1+1)*(NUM_MASTER+1)
  localparam int MASTER_PORTS_DATA_BUF_DW = (master_ports_DATA_WIDTH-1+1)*(NUM_MASTER+1);
  localparam int MASTER_PORTS_DATA_BUF_NB_COL = (MASTER_PORTS_DATA_BUF_DW + 7) / 8;  // Number of bytes
  localparam int MASTER_PORTS_DATA_BUF_AW = $clog2(BUFFER_DEPTH);

  generate
    for (genvar inst = 0; inst < NUM_INSTANCES; inst++) begin : gen_master_ports_data_ibuf

      logic [MASTER_PORTS_DATA_BUF_NB_COL*8-1:0] master_ports_data_buf_demux_out;
      logic [MASTER_PORTS_DATA_BUF_NB_COL-1:0] master_ports_data_buf_demux_wea;
      logic [MASTER_PORTS_DATA_BUF_NB_COL*8-1:0] master_ports_data_buf_bram_out;

      // 8-bit Demux: 8-bit input -> (master_ports_DATA_WIDTH-1+1)*(NUM_MASTER+1)-bit BRAM data
      always_comb begin
        master_ports_data_buf_demux_out = '0;
        master_ports_data_buf_demux_wea = '0;
        if (master_ports_data_buf_wr_sel[inst] < MASTER_PORTS_DATA_BUF_NB_COL) begin
          // Check if this is the last byte
          if (master_ports_data_buf_wr_sel[inst] == MASTER_PORTS_DATA_BUF_NB_COL - 1 && MASTER_PORTS_DATA_BUF_DW % 8 != 0) begin
            // Last byte: only connect the necessary LSBs
            master_ports_data_buf_demux_out[master_ports_data_buf_wr_sel[inst]*8 +: (MASTER_PORTS_DATA_BUF_DW % 8)] = master_ports_data_buf_wr_data[inst][(MASTER_PORTS_DATA_BUF_DW % 8)-1:0];
          end else begin
            // Full byte
            master_ports_data_buf_demux_out[master_ports_data_buf_wr_sel[inst]*8 +: 8] = master_ports_data_buf_wr_data[inst];
          end
          master_ports_data_buf_demux_wea[master_ports_data_buf_wr_sel[inst]] = master_ports_data_buf_wea[inst];
        end
      end

      // BRAM with byte write enable for master_ports_data
      xilinx_single_port_byte_write_ram_read_first #(
        .NB_COL(MASTER_PORTS_DATA_BUF_NB_COL),
        .COL_WIDTH(8),
        .RAM_DEPTH(BUFFER_DEPTH),
        .RAM_PERFORMANCE("HIGH_PERFORMANCE"),
        .INIT_FILE("")
      ) master_ports_data_bram (
        .clka   (clk_i),
        .ena    (master_ports_data_buf_ena[inst]),
        .wea    (master_ports_data_buf_demux_wea),
        .addra  ({(MASTER_PORTS_DATA_BUF_AW){1'b0}}),  // Fixed address 0
        .dina   (master_ports_data_buf_demux_out),
        .rsta   (!resetn_i),
        .regcea (1'b1),
        .douta  (master_ports_data_buf_bram_out)
      );

      // Connect BRAM output to module input (truncate if needed)
      assign tcdm_xbar_master_ports_data = master_ports_data_buf_bram_out[MASTER_PORTS_DATA_BUF_DW-1:0];

    end
  endgenerate

  // Buffer for master_ports_r_data - BRAM data width = (master_ports_DATA_WIDTH-1+1)*(NUM_MASTER+1)
  localparam int MASTER_PORTS_R_DATA_BUF_DW = (master_ports_DATA_WIDTH-1+1)*(NUM_MASTER+1);
  localparam int MASTER_PORTS_R_DATA_BUF_NB_COL = (MASTER_PORTS_R_DATA_BUF_DW + 7) / 8;  // Number of bytes
  localparam int MASTER_PORTS_R_DATA_BUF_AW = $clog2(BUFFER_DEPTH);

  generate
    for (genvar inst = 0; inst < NUM_INSTANCES; inst++) begin : gen_master_ports_r_data_ibuf

      logic [MASTER_PORTS_R_DATA_BUF_NB_COL*8-1:0] master_ports_r_data_buf_demux_out;
      logic [MASTER_PORTS_R_DATA_BUF_NB_COL-1:0] master_ports_r_data_buf_demux_wea;
      logic [MASTER_PORTS_R_DATA_BUF_NB_COL*8-1:0] master_ports_r_data_buf_bram_out;

      // 8-bit Demux: 8-bit input -> (master_ports_DATA_WIDTH-1+1)*(NUM_MASTER+1)-bit BRAM data
      always_comb begin
        master_ports_r_data_buf_demux_out = '0;
        master_ports_r_data_buf_demux_wea = '0;
        if (master_ports_r_data_buf_wr_sel[inst] < MASTER_PORTS_R_DATA_BUF_NB_COL) begin
          // Check if this is the last byte
          if (master_ports_r_data_buf_wr_sel[inst] == MASTER_PORTS_R_DATA_BUF_NB_COL - 1 && MASTER_PORTS_R_DATA_BUF_DW % 8 != 0) begin
            // Last byte: only connect the necessary LSBs
            master_ports_r_data_buf_demux_out[master_ports_r_data_buf_wr_sel[inst]*8 +: (MASTER_PORTS_R_DATA_BUF_DW % 8)] = master_ports_r_data_buf_wr_data[inst][(MASTER_PORTS_R_DATA_BUF_DW % 8)-1:0];
          end else begin
            // Full byte
            master_ports_r_data_buf_demux_out[master_ports_r_data_buf_wr_sel[inst]*8 +: 8] = master_ports_r_data_buf_wr_data[inst];
          end
          master_ports_r_data_buf_demux_wea[master_ports_r_data_buf_wr_sel[inst]] = master_ports_r_data_buf_wea[inst];
        end
      end

      // BRAM with byte write enable for master_ports_r_data
      xilinx_single_port_byte_write_ram_read_first #(
        .NB_COL(MASTER_PORTS_R_DATA_BUF_NB_COL),
        .COL_WIDTH(8),
        .RAM_DEPTH(BUFFER_DEPTH),
        .RAM_PERFORMANCE("HIGH_PERFORMANCE"),
        .INIT_FILE("")
      ) master_ports_r_data_bram (
        .clka   (clk_i),
        .ena    (master_ports_r_data_buf_ena[inst]),
        .wea    (master_ports_r_data_buf_demux_wea),
        .addra  ({(MASTER_PORTS_R_DATA_BUF_AW){1'b0}}),  // Fixed address 0
        .dina   (master_ports_r_data_buf_demux_out),
        .rsta   (!resetn_i),
        .regcea (1'b1),
        .douta  (master_ports_r_data_buf_bram_out)
      );

      // Connect BRAM output to module input (truncate if needed)
      assign tcdm_xbar_master_ports_r_data = master_ports_r_data_buf_bram_out[MASTER_PORTS_R_DATA_BUF_DW-1:0];

    end
  endgenerate


  // =========================================================================
  // Output buffers (BRAM with mux) - per instance
  // =========================================================================

  // Buffer for slave_ports_addr - BRAM data width = (slave_ports_ADDR_WIDTH-1+1)*(NUM_SLAVE+1)
  localparam int SLAVE_PORTS_ADDR_BUF_DW = (slave_ports_ADDR_WIDTH-1+1)*(NUM_SLAVE+1);
  localparam int SLAVE_PORTS_ADDR_BUF_AW = $clog2(BUFFER_DEPTH);

  generate
    for (genvar inst = 0; inst < NUM_INSTANCES; inst++) begin : gen_slave_ports_addr_obuf

      logic [SLAVE_PORTS_ADDR_BUF_DW-1:0] slave_ports_addr_buf_bram_out;

      // BRAM for slave_ports_addr
      xilinx_single_port_ram_no_change #(
        .RAM_WIDTH(SLAVE_PORTS_ADDR_BUF_DW),
        .RAM_DEPTH(BUFFER_DEPTH),
        .RAM_PERFORMANCE("HIGH_PERFORMANCE"),
        .INIT_FILE("")
      ) slave_ports_addr_bram (
        .clka   (clk_i),
        .ena    (slave_ports_addr_buf_ena[inst]),
        .wea    (slave_ports_addr_buf_wea[inst]),
        .addra  ({(SLAVE_PORTS_ADDR_BUF_AW){1'b0}}),  // Fixed address 0
        .dina   (tcdm_xbar_slave_ports_addr),
        .rsta   (!resetn_i),
        .regcea (1'b1),
        .douta  (slave_ports_addr_buf_bram_out)
      );

      // Mux: (slave_ports_ADDR_WIDTH-1+1)*(NUM_SLAVE+1)-bit BRAM data -> 1-bit output
      always_comb begin
        slave_ports_addr_buf_rd_data[inst] = '0;
        if (slave_ports_addr_buf_rd_sel[inst] < SLAVE_PORTS_ADDR_BUF_DW) begin
          slave_ports_addr_buf_rd_data[inst][0] = slave_ports_addr_buf_bram_out[slave_ports_addr_buf_rd_sel[inst]];
        end
      end

    end
  endgenerate

  // Buffer for slave_ports_be - BRAM data width = ((slave_ports_DATA_WIDTH/8)-1+1)*(NUM_SLAVE+1)
  localparam int SLAVE_PORTS_BE_BUF_DW = ((slave_ports_DATA_WIDTH/8)-1+1)*(NUM_SLAVE+1);
  localparam int SLAVE_PORTS_BE_BUF_AW = $clog2(BUFFER_DEPTH);

  generate
    for (genvar inst = 0; inst < NUM_INSTANCES; inst++) begin : gen_slave_ports_be_obuf

      logic [SLAVE_PORTS_BE_BUF_DW-1:0] slave_ports_be_buf_bram_out;

      // BRAM for slave_ports_be
      xilinx_single_port_ram_no_change #(
        .RAM_WIDTH(SLAVE_PORTS_BE_BUF_DW),
        .RAM_DEPTH(BUFFER_DEPTH),
        .RAM_PERFORMANCE("HIGH_PERFORMANCE"),
        .INIT_FILE("")
      ) slave_ports_be_bram (
        .clka   (clk_i),
        .ena    (slave_ports_be_buf_ena[inst]),
        .wea    (slave_ports_be_buf_wea[inst]),
        .addra  ({(SLAVE_PORTS_BE_BUF_AW){1'b0}}),  // Fixed address 0
        .dina   (tcdm_xbar_slave_ports_be),
        .rsta   (!resetn_i),
        .regcea (1'b1),
        .douta  (slave_ports_be_buf_bram_out)
      );

      // Mux: ((slave_ports_DATA_WIDTH/8)-1+1)*(NUM_SLAVE+1)-bit BRAM data -> 1-bit output
      always_comb begin
        slave_ports_be_buf_rd_data[inst] = '0;
        if (slave_ports_be_buf_rd_sel[inst] < SLAVE_PORTS_BE_BUF_DW) begin
          slave_ports_be_buf_rd_data[inst][0] = slave_ports_be_buf_bram_out[slave_ports_be_buf_rd_sel[inst]];
        end
      end

    end
  endgenerate

  // Buffer for slave_ports_data - BRAM data width = (slave_ports_DATA_WIDTH-1+1)*(NUM_SLAVE+1)
  localparam int SLAVE_PORTS_DATA_BUF_DW = (slave_ports_DATA_WIDTH-1+1)*(NUM_SLAVE+1);
  localparam int SLAVE_PORTS_DATA_BUF_AW = $clog2(BUFFER_DEPTH);

  generate
    for (genvar inst = 0; inst < NUM_INSTANCES; inst++) begin : gen_slave_ports_data_obuf

      logic [SLAVE_PORTS_DATA_BUF_DW-1:0] slave_ports_data_buf_bram_out;

      // BRAM for slave_ports_data
      xilinx_single_port_ram_no_change #(
        .RAM_WIDTH(SLAVE_PORTS_DATA_BUF_DW),
        .RAM_DEPTH(BUFFER_DEPTH),
        .RAM_PERFORMANCE("HIGH_PERFORMANCE"),
        .INIT_FILE("")
      ) slave_ports_data_bram (
        .clka   (clk_i),
        .ena    (slave_ports_data_buf_ena[inst]),
        .wea    (slave_ports_data_buf_wea[inst]),
        .addra  ({(SLAVE_PORTS_DATA_BUF_AW){1'b0}}),  // Fixed address 0
        .dina   (tcdm_xbar_slave_ports_data),
        .rsta   (!resetn_i),
        .regcea (1'b1),
        .douta  (slave_ports_data_buf_bram_out)
      );

      // Mux: (slave_ports_DATA_WIDTH-1+1)*(NUM_SLAVE+1)-bit BRAM data -> 1-bit output
      always_comb begin
        slave_ports_data_buf_rd_data[inst] = '0;
        if (slave_ports_data_buf_rd_sel[inst] < SLAVE_PORTS_DATA_BUF_DW) begin
          slave_ports_data_buf_rd_data[inst][0] = slave_ports_data_buf_bram_out[slave_ports_data_buf_rd_sel[inst]];
        end
      end

    end
  endgenerate

  // Buffer for slave_ports_r_data - BRAM data width = (slave_ports_DATA_WIDTH-1+1)*(NUM_SLAVE+1)
  localparam int SLAVE_PORTS_R_DATA_BUF_DW = (slave_ports_DATA_WIDTH-1+1)*(NUM_SLAVE+1);
  localparam int SLAVE_PORTS_R_DATA_BUF_AW = $clog2(BUFFER_DEPTH);

  generate
    for (genvar inst = 0; inst < NUM_INSTANCES; inst++) begin : gen_slave_ports_r_data_obuf

      logic [SLAVE_PORTS_R_DATA_BUF_DW-1:0] slave_ports_r_data_buf_bram_out;

      // BRAM for slave_ports_r_data
      xilinx_single_port_ram_no_change #(
        .RAM_WIDTH(SLAVE_PORTS_R_DATA_BUF_DW),
        .RAM_DEPTH(BUFFER_DEPTH),
        .RAM_PERFORMANCE("HIGH_PERFORMANCE"),
        .INIT_FILE("")
      ) slave_ports_r_data_bram (
        .clka   (clk_i),
        .ena    (slave_ports_r_data_buf_ena[inst]),
        .wea    (slave_ports_r_data_buf_wea[inst]),
        .addra  ({(SLAVE_PORTS_R_DATA_BUF_AW){1'b0}}),  // Fixed address 0
        .dina   (tcdm_xbar_slave_ports_r_data),
        .rsta   (!resetn_i),
        .regcea (1'b1),
        .douta  (slave_ports_r_data_buf_bram_out)
      );

      // Mux: (slave_ports_DATA_WIDTH-1+1)*(NUM_SLAVE+1)-bit BRAM data -> 1-bit output
      always_comb begin
        slave_ports_r_data_buf_rd_data[inst] = '0;
        if (slave_ports_r_data_buf_rd_sel[inst] < SLAVE_PORTS_R_DATA_BUF_DW) begin
          slave_ports_r_data_buf_rd_data[inst][0] = slave_ports_r_data_buf_bram_out[slave_ports_r_data_buf_rd_sel[inst]];
        end
      end

    end
  endgenerate


  // =========================================================================
  // tcdm_xbar instantiation - 1 instance(s)
  // =========================================================================

  tcdm_xbar #(
    .NUM_MASTER(NUM_MASTER),
    .NUM_SLAVE(NUM_SLAVE),
    .DATA_WIDTH(DATA_WIDTH),
    .ADDR_WIDTH(ADDR_WIDTH),
    .BE_WIDTH(BE_WIDTH)
  ) u_tcdm_xbar (
    .clk_i(clk_i),
    .resetn_i(resetn_i),
    .master_ports(master_ports_intf),
    .slave_ports(slave_ports_intf)
  );

endmodule